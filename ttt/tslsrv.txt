https://mongoose.ws/documentation/tutorials/tls/
https://mongoose.ws/documentation/


postIncomingEvent


sendEventAllClients




public:
  //**************************************************************************
  //                                USERS
  //**************************************************************************

  // The list of users
  CUserList m_userList;

  // Mutex for users
  pthread_mutex_t m_mutex_UserList;

  //**************************************************************************
  //                                CLIENTS
  //**************************************************************************

  // The list with active clients. (protecting mutex in object)
  CClientList m_clientList;

  // Mutex for client queue
  pthread_mutex_t m_mutex_clientList;

  // Queue
  std::list<vscpEvent *> m_sendList;
  std::list<vscpEvent *> m_receiveList;


};


-----------------------------------------------------------------------------------------------------------------------



///////////////////////////////////////////////////////////////////////////////
// websock_new_session
//

websock_session*
websock_new_session(const struct mg_connection* conn)
{
    const char* pHeader;
    char ws_version[10];
    char ws_key[33];
    websock_session* pSession = NULL;

    // Check pointer
    if (NULL == conn)
        return NULL;

    // user
    memset(ws_version, 0, sizeof(ws_version));
    if (NULL != (pHeader = mg_get_header(conn, "Sec-WebSocket-Version"))) {
        strncpy(ws_version,
                pHeader,
                std::min(strlen(pHeader) + 1, sizeof(ws_version)));
    }
    memset(ws_key, 0, sizeof(ws_key));
    if (NULL != (pHeader = mg_get_header(conn, "Sec-WebSocket-Key"))) {
        strncpy(ws_key, pHeader, std::min(strlen(pHeader) + 1, sizeof(ws_key)));
    }

    // create fresh session
    pSession = new websock_session;
    if (NULL == pSession) {
        syslog(LOG_ERR,
               "[Websockets] New session: Unable to create session object.");
        return NULL;
    }

    // Generate the sid
    unsigned char iv[16];
    char hexiv[33];
    getRandomIV(iv, 16); // Generate 16 random bytes
    memset(hexiv, 0, sizeof(hexiv));
    vscp_byteArray2HexStr(hexiv, iv, 16);

    memset(pSession->m_sid, 0, sizeof(pSession->m_sid));
    memcpy(pSession->m_sid, hexiv, 32);
    memset(pSession->m_websocket_key, 0, sizeof(pSession->m_websocket_key));

    // Init.
    strcpy(pSession->m_websocket_key, ws_key); // Save key
    pSession->m_conn       = (struct mg_connection*)conn;
    pSession->m_conn_state = WEBSOCK_CONN_STATE_CONNECTED;
    pSession->m_version    = atoi(ws_version); // Store protocol version

    pSession->m_pClientItem = new CClientItem(); // Create client
    if (NULL == pSession->m_pClientItem) {
        syslog(LOG_ERR,
               "[Websockets] New session: Unable to create client object.");
        delete pSession;
        return NULL;
    }

    pSession->m_pClientItem->bAuthenticated = false; // Not authenticated in yet
    vscp_clearVSCPFilter(&pSession->m_pClientItem->m_filter); // Clear filter

    // This is an active client
    pSession->m_pClientItem->m_bOpen = false;
    pSession->m_pClientItem->m_dtutc = vscpdatetime::Now();
    pSession->m_pClientItem->m_type =
      CLIENT_ITEM_INTERFACE_TYPE_CLIENT_WEBSOCKET;
    pSession->m_pClientItem->m_strDeviceName = ("Internal websocket client.");

    // Add the client to the Client List
    pthread_mutex_lock(&gpobj->m_clientList.m_mutexItemList);
    if (!gpobj->addClient(pSession->m_pClientItem)) {
        // Failed to add client
        delete pSession->m_pClientItem;
        pSession->m_pClientItem = NULL;
        pthread_mutex_unlock(&gpobj->m_clientList.m_mutexItemList);
        syslog(LOG_ERR,
               ("Websocket server: Failed to add client. Terminating thread."));
        return NULL;
    }
    pthread_mutex_unlock(&gpobj->m_clientList.m_mutexItemList);

    pthread_mutex_lock(&gpobj->m_mutex_websocketSession);
    gpobj->m_websocketSessions.push_back(pSession);
    pthread_mutex_unlock(&gpobj->m_mutex_websocketSession);

    // Use the session object as user data
    mg_set_user_connection_data(pSession->m_conn, (void*)pSession);

    return pSession;
}

///////////////////////////////////////////////////////////////////////////////
// websock_sendevent
//
// Send event to all other clients.
//

bool
websock_sendevent(struct mg_connection* conn,
                  websock_session* pSession,
                  vscpEventEx* pex)
{
    // Check pointer
    if (NULL == conn) {
        syslog(LOG_ERR,"Internal error: websock_sendevent - conn == NULL");
        return false;
    }
    
    if (NULL == pSession) {
        syslog(LOG_ERR,"Internal error: websock_sendevent - pSession == NULL");
        return false;
    }

    if (NULL == pex) {
        syslog(LOG_ERR,"Internal error: websock_sendevent - pEvent == NULL");
        return false;
    }

    return gpobj->sendEvent(pSession->m_pClientItem, pex );
}

///////////////////////////////////////////////////////////////////////////////
// websocket_post_incomingEvent
//

void
websock_post_incomingEvents(void)
{
    pthread_mutex_lock(&gpobj->m_mutex_websocketSession);

    std::list<websock_session*>::iterator iter;
    for (iter = gpobj->m_websocketSessions.begin();
         iter != gpobj->m_websocketSessions.end();
         ++iter) {

        websock_session* pSession = *iter;
        if (NULL == pSession) {
            continue;
        }

        // Should be a client item... hmm.... client disconnected
        if (NULL == pSession->m_pClientItem) {
            continue;
        }

        if (pSession->m_conn_state < WEBSOCK_CONN_STATE_CONNECTED)
            continue;

        if (NULL == pSession->m_conn)
            continue;

        if (pSession->m_pClientItem->m_bOpen &&
            pSession->m_pClientItem->m_clientInputQueue.size()) {

            vscpEvent* pEvent;
            pthread_mutex_lock(
              &pSession->m_pClientItem->m_mutexClientInputQueue);
            pEvent = pSession->m_pClientItem->m_clientInputQueue.front();
            pSession->m_pClientItem->m_clientInputQueue.pop_front();
            pthread_mutex_unlock(
              &pSession->m_pClientItem->m_mutexClientInputQueue);
            if (NULL != pEvent) {

                // Run event through filter
                if (vscp_doLevel2Filter(pEvent,
                                        &pSession->m_pClientItem->m_filter)) {

                    // User must be authorized to receive events
                    if (!(pSession->m_pClientItem->m_pUserItem
                            ->getUserRights() &
                          VSCP_USER_RIGHT_ALLOW_RCV_EVENT)) {
                        continue;
                    }

                    std::string str;
                    if (vscp_convertEventToString(str, pEvent)) {

                        if (__VSCP_DEBUG_WEBSOCKET_RX) {
                            syslog(LOG_DEBUG,
                                   "Received ws event %s",
                                   str.c_str());
                        }

                        // Write it out
                        if (WS_TYPE_1 == pSession->m_wstypes) {
                            str = ("E;") + str;
                            mg_websocket_write(pSession->m_conn,
                                               MG_WEBSOCKET_OPCODE_TEXT,
                                               (const char*)str.c_str(),
                                               str.length());
                        }
                        else if (WS_TYPE_2 == pSession->m_wstypes) {
                            std::string strEvent;
                            vscp_convertEventToJSON(strEvent, pEvent);
                            std::string str =
                              vscp_str_format(WS2_EVENT, strEvent.c_str());
                            mg_websocket_write(pSession->m_conn,
                                               MG_WEBSOCKET_OPCODE_TEXT,
                                               (const char*)str.c_str(),
                                               str.length());
                        }
                    }
                }

                // Remove the event
                vscp_deleteEvent_v2(&pEvent);

            } // Valid pEvent pointer

        } // events available

    } // for

    pthread_mutex_unlock(&gpobj->m_mutex_websocketSession);
}
